## 0. Why This Project Matters

This project directly modifies kernel internals and is intended
for educational and experimental purposes only.

By directly modifying the syscall table, I experienced
multiple kernel panics and learned how unsafe symbol
resolution can crash the entire system.

Through this process, I gained a deeper understanding
of Linux kernel internals and developed a strong habit
of defensive thinking when working with low-level systems.

> âš ï¸ Note: Direct syscall table hooking is highly unsafe and
> not suitable for production systems. This approach was used
> strictly for educational purposes.

### Environment
- Linux Kernel: 5.4.282 (x86_64)
- Build: Custom kernel build
- VM: QEMU / VirtualBox
- Language: C


## ğŸ’¡ 1. í”„ë¡œì íŠ¸ ê°œìš” (Overview)
-  Assignment 1-1 : Make os_ftrace system call
-  Assignment 1-2 : Make Wrapping & hooking modules
-  Assignment 1-3 : Make trace modules

## 2. ì„¤ê³„ ë° êµ¬í˜„ ìƒì„¸ (Design & Implementation)

### 2-1. Flowchart

ğŸ“Œ  Assignment 1-1

<img src="images/flowchart1.png" height ="400px" width ="600px">

<br>

ğŸ“Œ Assignment 1-2, 1-3

<img src="images/flowchart2.png" height ="400px" width ="600px">

---

### 2.2. í•µì‹¬ ì½”ë“œ
 
ğŸ“Œ Assignment 1-1 

- os_ftrace.c

```
// Define System call
SYSCALL_DEFINE1(os_ftrace,pid_t,pid)
{
	printk(KERN_INFO"ORIGINAL ftrace() called! PID is [%d]\n",pid);
	return 0;

}
```

ğŸ“Œ Assignment 1-2

- ftracehooking.c

```
/*
* hook_init
* 
* 1. Locate sys_call_table using kallsyms
* 2. Save original syscall pointer
* 3. Temporarily disable write protection
* 4. Replace syscall entry with fook function
*/
static int  __init hook_init(void)
{
	sys_call_table = (unsigned long**)kallsyms_lookup_name("sys_call_table");

	if(!sys_call_table)
	{
		printk(KERN_ERR "Couldn't find sys_call_table\n");
		return -EINVAL;
	}

	real_os_ftrace = (os_ftrace_t)sys_call_table[__NR_os_ftrace];
	printk(KERN_INFO "saving real_os_ftrace = %px\n", real_os_ftrace);

	make_rw(sys_call_table);
	sys_call_table[__NR_os_ftrace] = (unsigned long*)my_ftrace; 
	make_ro(sys_call_table);

	printk(KERN_INFO "os_ftrace hooked!\n");

	return 0;
}


/*
* hook_exit - module unload routine
* 
* Restore original syscall pointer to prevent
*/
static void __exit hook_exit(void)
{
	if (!sys_call_table || !real_os_ftrace) return;
	
	make_rw(sys_call_table);
	sys_call_table[__NR_os_ftrace] = (unsigned long*)real_os_ftrace;
	make_ro(sys_call_table);

	printk(KERN_INFO "os_ftrace restored\n");
	
}

```

ğŸ“Œ Assignmnet 1-3

- ftracehooking.h
```
/*
* struct io_trace_stats - I/O tracing statistics
* 
* This structure stores statistics of file I/O operations
* performed by the traced process.
* 
* Counters are increased whenever the hooked functions
* are invoked through ftracehooking.c
*/
struct io_trace_stats{
	int		open_count;		/* number of open calls */
	int		close_count;	/* number of close calls */
	int		read_count;		/* number of read calls */
	int		write_count;	/* number of write calls */
	int		lseek_count;	/* number of lseek calls */

	size_t	read_bytes;		/* total bytes read */
	size_t	write_bytes;	/* total bytes written */

	char	filename[256];	/* last accessed file name */
};

/*stats
* 
* Global I/O statistics shared between modules
* Updated by ftrace hooks during runtime
*/
extern struct io_trace_stats stats; 

```

- ftracehooking.c
```
/* ============================================================
 *  Hooked os_ftrace syscall
 * ============================================================ */
asmlinkage long my_ftrace(pid_t pid)
{
    /* stop tracing */
    if (traced_pid && pid ==traced_pid){
        stop_io_trace();
        traced_pid = 0;
	    return 0;
    } 
   
    /* start tracing */
    if (pid > 0) { 
        start_io_trace(pid);
    }

    return 0;
}
```

- iotracehooking.c
```
/* ============================================================
 *  Trace control
 * ============================================================ */

void start_io_trace(pid_t pid)
{
    traced_pid = pid;
    syscall_table = (void**) kallsyms_lookup_name("sys_call_table");

    make_rw((unsigned long)syscall_table); 

    real_openat =(void*) syscall_table[__NR_openat];
    real_read = (void*)syscall_table[__NR_read];
    real_write =(void*) syscall_table[__NR_write];
    real_lseek =(void*) syscall_table[__NR_lseek];
    real_close =(void*) syscall_table[__NR_close];

    syscall_table[__NR_openat] = ftrace_openat;
    syscall_table[__NR_read] = ftrace_read;
    syscall_table[__NR_write] = ftrace_write;
    syscall_table[__NR_lseek] = ftrace_lseek;
    syscall_table[__NR_close] = ftrace_close;

    make_ro((unsigned long)syscall_table); 

    printk(KERN_INFO "[iotrace] pid%d tracing start\n",pid);
}
EXPORT_SYMBOL(start_io_trace);

void stop_io_trace(void)
{
    if(!syscall_table) return;
 
    make_rw((unsigned long)syscall_table);

    if (real_openat) syscall_table[__NR_openat] = (void *)real_openat;
    if (real_read)   syscall_table[__NR_read]   = (void *)real_read;
    if (real_write)  syscall_table[__NR_write]  = (void *)real_write;
    if (real_lseek)  syscall_table[__NR_lseek]  = (void *)real_lseek;
    if (real_close)  syscall_table[__NR_close]  = (void *)real_close;

    make_ro((unsigned long)syscall_table);

    printk(KERN_INFO "[2021202089] %s file[%s] stats [x] read - %zd / written - %zd",
                    current->comm,stats.filename,stats.read_bytes,stats.write_bytes);
    printk(KERN_INFO "open[%d] close[%d] read[%d] write[%d] lseek[%d]",
                    stats.open_count,stats.close_count,stats.read_count,stats.write_count,stats.lseek_count);

    printk(KERN_INFO "OS Assignment2 ftrace [%d] End\n",current->pid);
}
EXPORT_SYMBOL(stop_io_trace);

```
---

## 3. ì»¤ë„ ìˆ˜ì • ë° ë¹Œë“œ ì ˆì°¨ 

### ë¹Œë“œ ë° ì„¤ì¹˜

#### 3-1. Kernel Compile

<img src="images/kernel-compile.png" height = "300px" width="600px">


#### 3-2. nokaslr ì„¤ì •
- Grubì—ì„œ nokaslr ì„¤ì •ì´ ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. 
- KASLR (Kernel Address Space Layout Randomization)ì´ë€ ì»¤ë„ì´ ë¶€íŒ…ë  ë•Œë§ˆë‹¤ ì»¤ë„ ì½”ë“œì™€ ë°ì´í„°ê°€ ìœ„ì¹˜í•˜ëŠ” ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ ë¬´ì‘ìœ„ë¡œ ë°”ê¾¸ëŠ” ë³´ì•ˆ ê¸°ìˆ ì…ë‹ˆë‹¤.
- Assignment1ì—ì„œëŠ” ì»¤ë„ ì£¼ì†Œë¥¼ ì§ì ‘ ì°¸ì¡°í•˜ê±°ë‚˜ ìˆ˜ì •í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— í•´ë‹¹ ì„¤ì •ì„ êº¼ì•¼ í•©ë‹ˆë‹¤.

![alt text](images/grub-nokaslr-setting_1.png)

- $ vi etc/default/grub (Grub ì„¤ì • íŒŒì¼ ìˆ˜ì •)
- $sudo update-grub (Grub ì„¤ì • íŒŒì¼ ìˆ˜ì •)

![alt text](images/grub-nokaslr-setting_2.png)

#### 3.3. Kernel Source ë‹¤ìš´ë¡œë“œ
-  http://www.kernel.org ì—ì„œ ë‹¤ìš´ë¡œë“œë¥¼ ì§„í–‰í•©ë‹ˆë‹¤. ( ë²„ì „ : 5.4.282)
-  $ sudo wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.4.282.tar.xz ( root ê¶Œí•œí•„ìš” )
- $ tar -xvf linux-5.4.282.tar.xz ( ì½”ë“œ ì••ì¶• í•´ì œ)

#### 3.4 Kernel Extra Version ìˆ˜ì • (ì„ íƒ)
- $ cd linux-5.4.282 
- $ vi Makefile

![alt text](images/kernel-extra.png)

#### 3.4. Kernel í™˜ê²½ ì„¤ì •
- $ sudo apt install build-essential libncurses5-dev bison flex libssl-dev libelf-dev dwarves zstd
- $ sudo make menuconfig

![alt text](images/kernel-menuconfig0.png)

(1) ì»¤ë„ ëª¨ë“ˆ ì ì¬ ì‹œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤.
- â€œEnable loadable module supportâ€ Ã¨ â€œForced module loadingâ€ ì²´í¬
- ESC ë‘ ë²ˆ ì—°ì† ì…ë ¥ ì‹œ ì´ì „ ë©”ë‰´ë¡œ ë³µê·€

![alt text](images/kernel-menuconfig1.png)
- 

(2) ì»´íŒŒì¼ ì‹œ ë¬¸ì œê°€ ë  ìˆ˜ ìˆëŠ” ëª¨ë“ˆì„ ì œê±°í•©ë‹ˆë‹¤.
- â€œDevice Driversâ€ -> â€œStaging driversâ€ ì²´í¬ í•´ì œ

![alt text](images/kernel-menuconfig2.png)

(3) ì»´íŒŒì¼ ì‹œ ë¬¸ì œê°€ ë  ìˆ˜ ìˆëŠ” ì˜µì…˜ì„ ì œê±°í•©ë‹ˆë‹¤.

- â€œBinary Emulationsâ€ -> â€œx32 ABI for 64-bit modeâ€ ì²´í¬ í•´ì œ

![alt text](images/kernel-menuconfig3-1.png)
![alt text](images/kernel-menuconfig3-2.png)

(4) ì„¤ì •ì„ íŒŒì¼(.config)ì— ì €ì¥í•©ë‹ˆë‹¤.

![alt text](images/kernel-menuconfig4-1.png)
![alt text](images/kernel-menuconfig4-2.png)
![alt text](images/kernel-menuconfig4-3.png)

(5) ì‹œìŠ¤í…œ íê¸°í‚¤ ë° ë³´ì•ˆí‚¤ ë¹„í™œì„±í™”
- ìŠ¤í¬ë¦½íŠ¸ í™œìš©í•˜ì—¬ ìˆ˜ì •
- $ scripts/config --disable SYSTEM_TRUSTED_KEYS
- $ scripts/config --disable SYSTEM_REVOCATION_KEYS

![alt text](images/kernel-menuconfig5.png)

(6) initramfs ì„¤ì • ë³€ê²½
- Error : initd is too big ë°©ì§€ë¥¼ ìœ„í•œ ëª¨ë“ˆ ì„¤ì •
- $ cd /etc/initramfs-tools
- $ vi initramfs.conf

![alt text](images/kernel-menuconfig6.png)

#### 3.5 ì¬ë¶€íŒ…
- $ reboot
- Grub ë¶€íŠ¸ë¡œë” ì„ íƒ ë©”ë‰´ì—ì„œ ì»´íŒŒì¼í•œ ì»¤ë„ ì„ íƒ

![alt text](images/reboot1.png)
![alt text](images/reboot2.png)

- ì»¤ë„ ë²„ì „ í™•ì¸
- $ uname -r

![alt text](images/reboot3.png)

---

<br>

## 4. ë¦¬íŒ©í† ë§ ë° ìµœì í™” ì‚¬í•­ 

#### ëª©í‘œ
- ì½”ë“œ ê°€ë…ì„± í–¥ìƒ ë° ì»¤ë„ ì•ˆì •ì„± í™•ë³´
- ì¤‘ë³µ ë¡œì§ ì œê±° ë° í•¨ìˆ˜ ë‹¨ìœ„ ê¸°ëŠ¥ ë¶„ë¦¬

#### ì£¼ìš” ìˆ˜ì • ì‚¬í•­

#### Assignment 1-2: Process Tracer

-  ì¤‘ë³µëœ ftrace wrapper ì œê±°
-  ë¶ˆí•„ìš”í•œ __SYSCALL_DEFINEX ì‚¬ìš© ì œê±°
-  í•˜ë“œì½”ë”©ëœ syscall ë²ˆí˜¸(336) ìƒìˆ˜í™”
-  syscall index ì˜ì¡´ì„± ëª…í™•í™”
-  ë¡œê·¸ ë©”ì‹œì§€ í†µì¼
-  make_rw / make_ro ì•ˆì •ì„± ê°•í™”
-  í•¨ìˆ˜ ì„ ì–¸ ìœ„ì¹˜ ì •ë¦¬
-  static / const ì •í™•íˆ ì‚¬ìš©
-  ì»¤ë„ ì½”ë”© ì»¨ë²¤ì…˜ ì •ë ¬

#### Assignment 1-3: Process Tracer

- ì¤‘ë³µ ì½”ë“œ ì •ë¦¬
- ì‹œìŠ¤í…œ ì½œ ë§¤ì§ ë„˜ë²„ ì œê±°
- í•¨ìˆ˜ í¬ì¸í„° íƒ€ì… ì¶”ìƒí™” (typedef)
- í›„í‚¹ ë¡œì§ íë¦„ êµ¬ì¡° ê°œì„ 
- ë””ë²„ê·¸ ë¡œê·¸ ì •ë¦¬ ë° ìµœì†Œí™”
- ì „ì—­ í†µê³„ êµ¬ì¡° ì´ˆê¸°í™” ìœ„ì¹˜ ê°œì„ 
- ì½”ë“œ ìŠ¤íƒ€ì¼ ë° ì£¼ì„ í˜•ì‹ í†µì¼

---

## 5. ì‹¤í–‰ ê²°ê³¼ ë° í…ŒìŠ¤íŠ¸ 

ğŸ“Œ Assignment 1-1

#### 0) ê¸°ë³¸ ê²½ë¡œ
```
home/linux-5.4.282
```

#### 1) System call table ë“±ë¡
```
$ sudo cd /linux-5.4.282 
$ sudo vi arch/x86/entry/syscalls/syscall_64.tbl # ì‹œìŠ¤í…œ ì½œ í…Œì´ë¸” ë“±ë¡
$ sudo vi linux-5.4.282/include/linux/syscalls.h # ì‹œìŠ¤í…œ ì½œ í…Œì´ë¸” ë“±ë¡
```

#### 2) System Call í•¨ìˆ˜ ì‘ì„± (os_ftrace.c)
```
$ sudo mkdir linux-5.4.282/os_ftrace
$ sudo vi os_ftrace/os_ftrace.c
```

#### 3) System call í•¨ìˆ˜ì— ëŒ€í•œ Makefile ì‘ì„±
```
$ sudo vi os_ftrace/Makefile
```

#### 4) ì»¤ë„ ì»´íŒŒì¼ 
```
$ sudo make -j3
$ sudo make modules_install
$ sudo make install
```

#### 5) ë°©ê¸ˆ ì»´íŒŒì¼ í•œ ì»¤ë„ë¡œ ë¶€íŒ…
```
$ sudo reboot
```

#### 5) í…ŒìŠ¤íŠ¸ í”„ë¡œê·¸ë¨ ì‘ì„±
```
$ sudo vi os_ftrace/test.c
$ sudo gcc test.c -o test
$ sudo ./test
```

```
#include <stdio.h> /* printf() */
#include <unistd.h> /* syscall() */
#include <sys/syscall.h> /* syscall() */

int main(void)
{
        pid_t pid = getpid();
        long ret;

        ret = syscall(548,pid);
        printf("%ld\n",ret);

        return 0;
}     
```

#### 6) ë¡œê·¸ í™•ì¸
```
$ dmesg | tail -n 3
```

![alt text](images/dmesg1-1.png)

---

ğŸ“Œ Assignment 1-2
#### 0) ê¸°ë³¸ ê²½ë¡œ
```
home/as1-2
```


#### 1) ëª¨ë“ˆ ì†ŒìŠ¤ í”„ë¡œê·¸ë¨ ì‘ì„± â€“ os_ftracehooking.c - os_ftrace ì‹œìŠ¤í…œì½œ hijackí•˜ì—¬ my_ftraceí•¨ìˆ˜ë¡œ ëŒ€ì²´í•˜ëŠ” íˆ´

```
$ cd  # í™ˆìœ¼ë¡œ ì´ë™
$ mkidr moduletest
$ vi os_ftracehooking.c
```

#### 2) ëª¨ë“ˆ ì†ŒìŠ¤ í”„ë¡œê·¸ë¨ ì‘ì„± - Makefile ì‘ì„±
```
$ vi Makefile
```

#### 3) ì†ŒìŠ¤ ì»´íŒŒì¼
```
$ make clean && make
```

#### 4) í…ŒìŠ¤íŠ¸ í”„ë¡œê·¸ë¨ ì‘ì„±
```
$ vi test.c

```

```
#include <stdio.h> /* printf() */
#include <unistd.h> /* syscall() */
#include <sys/syscall.h> /* syscall() */

int main(void)
{
        pid_t pid = getpid();
        long ret;

        ret = syscall(548,pid);
        printf("%ld\n",ret);

        return 0;
}     
```

#### 5) ëª¨ë“ˆ ì ì¬
```
$ sudo insmod os_ftracehooking.ko
```

#### 6) ëª¨ë“ˆ ë™ì‘ í™•ì¸
```
$ ./test
```

#### 7) ëª¨ë“ˆ ì œê±° 
```
$ sudo rmmod os_ftracehooking # ëª¨ë“ˆ ì œê±°
$ lsmod | grep os_ftracehooking # ì œê±°ëëŠ”ì§€ í™•ì¸
```

#### 8) ë¡œê·¸ í™•ì¸
```
$ dmesg | tail -n 3
```
![alt text](images/dmesg1-2.png)
---

ğŸ“Œ Assignment 1-3

#### 0) ê¸°ë³¸ ê²½ë¡œ
```
home/as1-3
```

#### 1) ftracehooking.h ì‘ì„± - êµ¬ì¡°ì²´ ì •ì˜
```
$ mkdir as1-3
$ vi ftracehooking.h
```

#### 2) ftracehooking.c ì‘ì„± - os_ftrace ì‹œìŠ¤í…œì½œ hijackí•˜ì—¬ my_ftraceí•¨ìˆ˜ë¡œ ëŒ€ì²´í•˜ëŠ” íˆ´
```
$ vi ftracehooking.c
```

#### 3) iotracehooking.c ì‘ì„± - íŠ¹ì • pidì— ëŒ€í•˜ì—¬ íŒŒì¼ì— ê´€í•œ ì‹œìŠ¤í…œì½œì„ ì¶”ì í•˜ëŠ” íˆ´
```
$ vi iotracehooking.c
```

#### 4) Makefile ì‘ì„±
```
$ vi Makefile
```

#### 5) ì†ŒìŠ¤ ì»´íŒŒì¼
```
$ make clean && make
```

#### 6) ëª¨ë“ˆ ì ì¬
```
$ sudo insmod iotracehooking.ko
$ sudo insmode ftracehooking.ko
```

#### 7) ëª¨ë“ˆ ì ì¬ í™•ì¸
```
$ lsmod | grep hooking
```
#### 8) í…ŒìŠ¤íŠ¸ í”„ë¡œê·¸ë¨ ì‘ì„± ë° ì‹¤í–‰
```
$ vi test.c
$ ./test
```

```
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/syscall.h>

int main()
{
        long pid = getpid();
        syscall(548,pid);  // ì»¤ë„ ëª¨ë“ˆì— pid ì „ë‹¬
        int fd = 0;
        char buf[50];
        fd  = open("abc.txt",O_RDWR);
        if(fd<0)
        {
                perror("open");
                return 1;
        }

        for(int i = 1; i<=4;i++)
        {
                read(fd,buf,5); // íŒŒì¼ì—ì„œ 5ë°”ì´íŠ¸ ì½ìŒ
                lseek(fd,0,SEEK_END); // íŒŒì¼ ëìœ¼ë¡œ ì´ë™
                write(fd,buf,5); // ì½ì€ 5ë°”ì´íŠ¸ë¥¼ íŒŒì¼ ëì— ê¸°ë¡
                lseek(fd,i*5,SEEK_SET); // íŒŒì¼ í¬ì¸í„°ë¥¼ i*5 ìœ„ì¹˜ë¡œ ì„¤ì •
        }
        lseek(fd,0,SEEK_END);
        write(fd,"HELLO",strlen("HELLO"));
        close(fd);

        printf("Calling os_ftrace(0)...\n");
        fflush(stdout);
        syscall(548,0);
        sleep(1);
        printf("Finished test.\n");
        return 0;
}


```

#### 9) ëª¨ë“ˆ ì œê±°
```
$ sudo rmmod ftracehooking.ko
$ sudo rmmod iotracehooking.ko
```
#### 10) ë¡œê·¸ í™•ì¸
```
$ dmesg | tail -n 4
```
![alt text](images/dmesg1-3.png)

---

## 6. ë¬¸ì œ í•´ê²° ë° ê³ ì°° (Troubleshooting & Conclusion)

### 6-1. ë¬¸ì œ ë°œìƒ ë° ì›ì¸ ë¶„ì„
ê³¼ì œ 1-3ì˜ í…ŒìŠ¤íŠ¸ í”„ë¡œê·¸ë¨(./test) ì‹¤í–‰ ì‹œ, "CPU disabled by guest" ë©”ì‹œì§€ì™€ í•¨ê»˜ ê°€ìƒ ë¨¸ì‹ (VM)ì´ ì¤‘ë‹¨ë˜ëŠ” í˜„ìƒì´ ë°œìƒí•˜ì˜€ë‹¤. dmesgë¥¼ í†µí•œ ì»¤ë„ ë¡œê·¸ ë¶„ì„ ê²°ê³¼, í•´ë‹¹ í˜„ìƒì€ Kernel Panicì— ì˜í•œ ê²ƒìœ¼ë¡œ í™•ì¸ë˜ì—ˆë‹¤.

ì›ì¸ì€ ê¸°ì¡´ iotracehooking.cì˜ ì›ë³¸ í•¨ìˆ˜ ì£¼ì†Œ íšë“ ë°©ì‹ì— ìˆì—ˆë‹¤. kallsyms_lookup_name()ì„ ì´ìš©í•´ __x64_sys_openat ë“± ê°œë³„ ì‹œìŠ¤í…œ ì½œ ì‹¬ë³¼ì„ ì§ì ‘ ê²€ìƒ‰í•˜ì—¬ ì°¸ì¡°í•˜ì˜€ìœ¼ë‚˜, ì´ ê³¼ì •ì—ì„œ ìœ íš¨í•˜ì§€ ì•Šì€ í•¨ìˆ˜ í¬ì¸í„° ì£¼ì†Œê°€ ë°˜í™˜ë˜ì—ˆë‹¤. ì´ë¡œ ì¸í•´ ê¶Œí•œ ë ˆë²¨ 0(Kernel Mode)ì—ì„œ CPUê°€ ì˜ëª»ëœ ëª…ë ¹(Invalid Instruction)ì„ ì‹¤í–‰í•˜ë ¤ê³  ì‹œë„í•˜ë©´ì„œ ì‹œìŠ¤í…œì´ ë³´í˜¸ë¥¼ ìœ„í•´ ë™ì‘ì„ ë©ˆì¶˜ ê²ƒìœ¼ë¡œ íŒë‹¨ëœë‹¤.

### 6-2. í•´ê²° 
ê¸°ì¡´ ì½”ë“œì—ì„œëŠ” kallsyms_lookup_nameì„ í˜¸ì¶œí•˜ì—¬ ê° ì‹œìŠ¤í…œ ì½œì˜ ì‹¬ë³¼ ì´ë¦„(__x64_sys_openat ë“±)ì„ ì§ì ‘ ì°¾ì•„ ì›ë³¸ ì£¼ì†Œë¥¼ ì €ì¥í–ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ìµœì‹  ì»¤ë„ í™˜ê²½ì´ë‚˜ íŠ¹ì • ì•„í‚¤í…ì²˜ì—ì„œëŠ” ì‹¬ë³¼ ì´ë¦„ê³¼ ì‹¤ì œ ì‹¤í–‰ë˜ëŠ” ì‹œìŠ¤í…œ ì½œ í•¸ë“¤ëŸ¬ ê°„ì˜ ë¶ˆì¼ì¹˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë©°, ì´ë¡œ ì¸í•´ ìœ íš¨í•˜ì§€ ì•Šì€ ì£¼ì†Œë¥¼ í˜¸ì¶œí•˜ê²Œ ë˜ì–´ CPUì˜ General Protection Fault í˜¹ì€ Kernel Panicì´ ìœ ë°œë˜ì—ˆìŠµë‹ˆë‹¤.

ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´, ì´ë¯¸ ì•ˆì •ì ìœ¼ë¡œ í™•ë³´í•œ sys_call_tableì˜ í•´ë‹¹ ì¸ë±ìŠ¤(__NR_xxx)ì— ì €ì¥ëœ ê°’ì„ ì§ì ‘ ì½ì–´ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€ê²½í•˜ì˜€ìŠµë‹ˆë‹¤. ì´ ë°©ì‹ì€ ì»¤ë„ì´ ì‹œìŠ¤í…œ ì½œì„ ì²˜ë¦¬í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ì‹¤ì œ í…Œì´ë¸”ì˜ ê°’ì„ 1:1ë¡œ ë°±ì—…í•˜ë¯€ë¡œ, ì‹¬ë³¼ ì´ë¦„ ë¶ˆì¼ì¹˜ ë¬¸ì œë¥¼ ì›ì²œì ìœ¼ë¡œ ì°¨ë‹¨í•˜ê³  ì•ˆì •ì ì¸ ë³µêµ¬(Restore)ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤.

### 6-3. ë¬¸ì œê°€ ë°œìƒí•œ ì½”ë“œ (iotracehooking.c)

```
void start_io_trace(pid_t pid)
{
    traced_pid = pid;
    syscall_table = (void**) kallsyms_lookup_name("sys_call_table");

    make_rw((unsigned long)syscall_table); 
   /* ============================ ë¬¸ì œê°€ ë°œìƒí•œ ë¶€ë¶„ ========================== */
    real_openat =(void*)kallsyms_lookup_name("__x64_sys_openat);
    real_read = (void*)kallsyms_lookup_name("__x64_sys_read);
    real_write =(void*) kallsyms_lookup_name("__x64_sys_write);
    real_lseek =(void*) kallsyms_lookup_name("__x64_sys_lseek);
    real_close =(void*) kallsyms_lookup_name("__x64_sys_close);
   /* ======================================================================== */
    syscall_table[__NR_openat] = ftrace_openat;
    syscall_table[__NR_read] = ftrace_read;
    syscall_table[__NR_write] = ftrace_write;
    syscall_table[__NR_lseek] = ftrace_lseek;
    syscall_table[__NR_close] = ftrace_close;

    make_ro((unsigned long)syscall_table); 

    printk(KERN_INFO "[iotrace] pid%d tracing start\n",pid);
}

EXPORT_SYMBOL(start_io_trace);

void stop_io_trace(void)
{
    if(!syscall_table) return;
 
    make_rw((unsigned long)syscall_table);
   /* ============================ ë¬¸ì œê°€ ë°œìƒí•œ ë¶€ë¶„ ========================== */
    if (real_openat) syscall_table[__NR_openat] = (void *)real_openat;
    if (real_read)   syscall_table[__NR_read]   = (void *)real_read;
    if (real_write)  syscall_table[__NR_write]  = (void *)real_write;
    if (real_lseek)  syscall_table[__NR_lseek]  = (void *)real_lseek;
    if (real_close)  syscall_table[__NR_close]  = (void *)real_close;
   /* ======================================================================== */
    make_ro((unsigned long)syscall_table);

    printk(KERN_INFO "[2021202089] %s file[%s] stats [x] read - %zd / written - %zd",
                    current->comm,stats.filename,stats.read_bytes,stats.write_bytes);
    printk(KERN_INFO "open[%d] close[%d] read[%d] write[%d] lseek[%d]",
                    stats.open_count,stats.close_count,stats.read_count,stats.write_count,stats.lseek_count);

    printk(KERN_INFO "OS Assignment2 ftrace [%d] End\n",current->pid);
}
EXPORT_SYMBOL(stop_io_trace);

```


### 6-4. í•´ê²°ëœ ì½”ë“œ (iotracehooking.c)

```
void start_io_trace(pid_t pid)
{
    traced_pid = pid;
    syscall_table = (void**) kallsyms_lookup_name("sys_call_table");

    make_rw((unsigned long)syscall_table); 
   /* ============================ ìˆ˜ì •ëœ ë¶€ë¶„ ========================== */
    real_openat =(void*) syscall_table[__NR_openat];
    real_read = (void*)syscall_table[__NR_read];
    real_write =(void*) syscall_table[__NR_write];
    real_lseek =(void*) syscall_table[__NR_lseek];
    real_close =(void*) syscall_table[__NR_close];

    syscall_table[__NR_openat] = ftrace_openat;
    syscall_table[__NR_read] = ftrace_read;
    syscall_table[__NR_write] = ftrace_write;
    syscall_table[__NR_lseek] = ftrace_lseek;
    syscall_table[__NR_close] = ftrace_close;
   /* ================================================================== */
    make_ro((unsigned long)syscall_table); 

    printk(KERN_INFO "[iotrace] pid%d tracing start\n",pid);
}

EXPORT_SYMBOL(start_io_trace);

void stop_io_trace(void)
{
    if(!syscall_table) return;
 
    make_rw((unsigned long)syscall_table);

    if (real_openat) syscall_table[__NR_openat] = (void *)real_openat;
    if (real_read)   syscall_table[__NR_read]   = (void *)real_read;
    if (real_write)  syscall_table[__NR_write]  = (void *)real_write;
    if (real_lseek)  syscall_table[__NR_lseek]  = (void *)real_lseek;
    if (real_close)  syscall_table[__NR_close]  = (void *)real_close;

    make_ro((unsigned long)syscall_table);

    printk(KERN_INFO "[2021202089] %s file[%s] stats [x] read - %zd / written - %zd",
                    current->comm,stats.filename,stats.read_bytes,stats.write_bytes);
    printk(KERN_INFO "open[%d] close[%d] read[%d] write[%d] lseek[%d]",
                    stats.open_count,stats.close_count,stats.read_count,stats.write_count,stats.lseek_count);

    printk(KERN_INFO "OS Assignment2 ftrace [%d] End\n",current->pid);
}
EXPORT_SYMBOL(stop_io_trace);
```

---

## 7. í•œê³„ì  ë° í–¥í›„ ê°œì„  ë°©í–¥

### 7-1. í•œê³„ì 

- ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ: ëª¨ë“  ì‹œìŠ¤í…œ ì½œì„ í›„í‚¹í•˜ì—¬ í†µê³„ë¥¼ ìŒ“ëŠ” ë°©ì‹ì´ ì‹œìŠ¤í…œ ì „ì²´ ì„±ëŠ¥(Throughput)ì— ë¯¸ì¹˜ëŠ” ì˜í–¥.
- Race Condition: ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ê°€ ë™ì‹œì— í›„í‚¹ëœ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ë•Œ stats êµ¬ì¡°ì²´(ì „ì—­ ë³€ìˆ˜)ì— ëŒ€í•œ ë™ê¸°í™” ë¬¸ì œ.
- ì»¤ë„ ë²„ì „ ì˜ì¡´ì„±: íŠ¹ì • ì»¤ë„ ë²„ì „(5.4.282)ì— ì¢…ì†ì ì¸ êµ¬ì¡°(syscall table ìœ„ì¹˜ ë“±)ì— ëŒ€í•œ í•œê³„.

### 7-2: ê°œì„  ë°©í–¥

-  Docker ì»¨í…Œì´ë„ˆ ê¸°ë°˜ì˜ ì»¤ë„ ë¹Œë“œ ìë™í™” í™˜ê²½ êµ¬ì¶• ë° QEMU ì—°ë™ì„ í†µí•œ ë…ë¦½ì ì¸ ì»¤ë„ ëª¨ë“ˆ í…ŒìŠ¤íŠ¸ ìƒŒë“œë°•ìŠ¤ êµ¬í˜„


---